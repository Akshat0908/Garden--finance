var y = (t, r, e) => {
  if (!r.has(t))
    throw TypeError("Cannot " + e);
};
var u = (t, r, e) => (y(t, r, "read from private field"), e ? e.call(t) : r.get(t)), h = (t, r, e) => {
  if (r.has(t))
    throw TypeError("Cannot add the same private member more than once");
  r instanceof WeakSet ? r.add(t) : r.set(t, e);
}, l = (t, r, e, s) => (y(t, r, "write to private field"), s ? s.call(t, e) : r.set(t, e), e);
const d = (t) => new Promise((r) => setTimeout(r, t));
class x {
  /**
   * @param {number} maxRetries - The maximum number of retries, if less < 0 then it is set to 0
   * @param {number} delay - The delay between retries
   */
  constructor(r, e) {
    this.maxRetries = Math.max(r, 0), this.delay = e;
  }
  /**
   * Retries a function until it succeeds or the max number of retries is reached
   *
   * @param {() => Promise<T>} fn - The function to retry
   * @return {Promise<T>} a Promise that resolves to the result of the function
   */
  async retry(r) {
    let e = 0, s;
    for (; e < this.maxRetries + 1; )
      try {
        return await r();
      } catch (n) {
        e++, s = n, await d(this.delay * e);
      }
    throw s;
  }
}
const p = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
};
class k {
  static async _postWithFallback(r, e) {
    let s = "";
    for (const n of r)
      try {
        const a = await fetch(n, {
          method: "POST",
          ...e
        });
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback logic.
   *
   * @param {string[]} input - array of URLs to send the POST request to
   * @param {RequestInit} [init] - optional request initialization options
   * @return {Promise<T>} a Promise that resolves to the parsed response data
   */
  static async postWithFallback(r, e) {
    return await w(e).retry(
      () => this._postWithFallback(r, e)
    );
  }
  static async _getWithFallback(r, e) {
    let s = "";
    for (const n of r)
      try {
        const a = await fetch(n, e);
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback mechanism.
   *
   * @param {string[]} input - An array of URLs to retrieve data from.
   * @param {RequestInit} [init] - Optional request options.
   * @return {Promise<T>} A promise that resolves to the retrieved data.
   */
  static async getWithFallback(r, e) {
    return await w(e).retry(
      () => this._getWithFallback(r, e)
    );
  }
  static async _get(r, e) {
    return await this.parse(await fetch(r, e));
  }
  /**
   * Asynchronously retrieves data of type T from the specified URL or RequestInfo, with optional initialization options.
   *
   * @param {RequestInfo | URL} input - The URL or RequestInfo to fetch data from
   * @param {RequestInit} init - Optional initialization options for the fetch request
   * @return {Promise<T>} The retrieved data of type T
   */
  static async get(r, e) {
    return await w(e).retry(() => this._get(r, e));
  }
  static async _post(r, e) {
    return await this.parse(
      await fetch(r, {
        method: "POST",
        ...e
      })
    );
  }
  /**
   * Asynchronously sends a POST request to the specified URL or RequestInfo, with optional initialization options.
   */
  static async post(r, e) {
    return await w(e).retry(() => this._post(r, e));
  }
  /**
   * Parses the response and returns the result as the specified type.
   *
   * @param {Response} res - the response object to be parsed
   * @return {Promise<T>} the parsed result of type T
   */
  static async parse(r) {
    const e = await r.text();
    if (r.status >= 200 && r.status < 300)
      return p(e);
    throw new Error(e);
  }
}
function g(t) {
  return (t == null ? void 0 : t.message) || (t == null ? void 0 : t.toString()) || "unknown error";
}
const w = (t) => new x((t == null ? void 0 : t.retryCount) ?? 2, (t == null ? void 0 : t.retryDelay) ?? 1e3);
class b {
  constructor(r) {
    this.url = r;
  }
  /**
   * Sends a request and returns a response.
   *
   * @param {RpcRequest} request - The request to send.
   * @return {Promise<RpcResponse<T>>} - A promise that resolves to the response.
   */
  async sendRequest(r) {
    try {
      return await k.post(this.url, {
        body: JSON.stringify(r)
      });
    } catch (e) {
      return p(e.message);
    }
  }
}
const E = (t, r) => {
  if (!t)
    throw new Error(r);
  return t;
}, R = (t) => t.startsWith("0x") ? t : `0x${t}`, S = (t) => t.startsWith("0x") ? t.slice(2) : t;
var c, i, o;
class f {
  constructor(r, e, s = void 0) {
    h(this, c, void 0);
    h(this, i, void 0);
    h(this, o, void 0);
    l(this, c, r), l(this, o, s), l(this, i, e);
  }
  get ok() {
    return u(this, c);
  }
  get error() {
    return u(this, o);
  }
  get val() {
    return u(this, i);
  }
}
c = new WeakMap(), i = new WeakMap(), o = new WeakMap();
const W = (t) => new f(!0, t), P = void 0, F = (t, ...r) => {
  if (typeof t == "string" && r && r.length > 0) {
    let e = [t, ...r].map((s) => {
      if (s) {
        if (s instanceof Error)
          return s.message;
        if (typeof s == "string")
          return s;
        if (s != null && s.toString)
          return s.toString();
      }
    });
    return new f(
      !1,
      null,
      e.filter((s) => s !== void 0).join(" ")
    );
  }
  return new f(!1, null, t);
};
async function v(t, r = "Failed to execute") {
  try {
    const e = await t();
    return e instanceof f ? e : W(e);
  } catch (e) {
    return F(r + ": ", e);
  }
}
export {
  F as Err,
  k as Fetcher,
  b as JsonRpc,
  W as Ok,
  f as Result,
  x as Retry,
  P as Void,
  E as ensureVal,
  v as executeWithTryCatch,
  p as safeParseJson,
  d as sleep,
  S as trim0x,
  R as with0x
};
